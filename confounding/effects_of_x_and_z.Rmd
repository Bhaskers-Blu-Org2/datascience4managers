---
title: "Predicted effects of x and z"
output: html_document
runtime: shiny
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, message=FALSE)
```

```{r build_models, echo=FALSE, message=FALSE, warning=FALSE}
setwd("~/books_in_progress/managing_ML/MLADS_fall_2019")

library(nnet)
library(randomForest)
library(dplyr)
library(ggplot2)

DATA_DIR <- "models_and_data"

TRAIN_MODELS <- GENERATE_DATA <- FALSE

if (GENERATE_DATA){
  simulate_data <- function(N, m, b=0, noise=1){
    set.seed(1)
    x <- rnorm(N, sd=10*noise)
    y <- m[1] * x + b + rnorm(N, sd=noise)
    z <- y - (m[2]*x + b) + rnorm(N, sd=noise)
    tibble(y, x, z)
  }
  
  simdata <- simulate_data(1e4, c(-4, 5), noise=0.1)
  write.csv(simdata, filt.path(DATA_DIR, 'confounded_data.csv'))
} else {
  simdata <- read.csv(file.path(DATA_DIR,'confounded_data.csv'), stringsAsFactors=FALSE)
}


formula_A <- y ~ x
formula_B <- y ~ x + z

# model_names <- paste(rep(c('randomForest', 'nnet', 'lm'), each=2), c('A', 'B'), sep='_') %>% setNames(nm=.)


if (TRAIN_MODELS){
  lm_A <- lm(formula_A, simdata)
  lm_B <- lm(formula_B, simdata)
  
  randomForest_A <- randomForest(formula_A, simdata, ntree=15)
  randomForest_B <- randomForest(formula_B, simdata, ntree=15)
  
  nnet_A <- nnet(formula_A, simdata, size=10, linout=TRUE)
  nnet_B <- nnet(formula_B, simdata, size=10, linout=TRUE)
  
  saveRDS(lm_A, file.path(DATA_DIR, 'lm_A.Rds'))
  saveRDS(lm_B, file.path(DATA_DIR, 'lm_B.Rds'))
  saveRDS(randomForest_A, file.path(DATA_DIR, 'randomForest_A.Rds'))
  saveRDS(randomForest_B, file.path(DATA_DIR, 'randomForest_B.Rds'))
  saveRDS(nnet_A, file.path(DATA_DIR, 'nnet_A.Rds'))
  saveRDS(nnet_B, file.path(DATA_DIR, 'nnet_B.Rds'))
} else {
  lm_A <- readRDS(file.path(DATA_DIR, 'lm_A.Rds'))
  lm_B <- readRDS(file.path(DATA_DIR, 'lm_B.Rds'))
  randomForest_A <- readRDS(file.path(DATA_DIR, 'randomForest_A.Rds'))
  randomForest_B <- readRDS(file.path(DATA_DIR, 'randomForest_B.Rds'))
  nnet_A <- readRDS(file.path(DATA_DIR, 'nnet_A.Rds'))
  nnet_B <- readRDS(file.path(DATA_DIR, 'nnet_B.Rds'))
}


standard_predict <- function(model, test_data){
  if ('nnet' %in% class(model)){
    predict(model, test_data, type='raw')[,1]
  } else{
    predict(model, test_data)
  }
}

# plot(simdata$y, standard_predict(nnet_A, simdata), pch='.')
# points(simdata$y, standard_predict(nnet_B, simdata), pch='.', col='red')

# test1 <- data.frame(x=-0.62, z=5.01)

### Currently, y is perfectly predicted by x + z, because no noise was added
### We really want the two models A and b to have similar performance.


```

```{r eruptions, echo=FALSE, message=FALSE, warning=FALSE}

X_LIM <- c(-3, 3)
Z_LIM <- c(-30, 30)
Y_LIM <- c(-30, 30)

LOGGED_DATA <- data.frame(x=c(), z=c())

MODEL_TYPES <- c('lm', 'randomForest', 'nnet')
MODEL_FORMULAS <- c('A', 'B')

MODEL_NAMES <- paste(MODEL_TYPES, rep(MODEL_FORMULAS, times=length(MODEL_TYPES)), sep='_')

SCENARIOS <- list(
  medicine = list(x='drug', y='pain', z='age'),
  maintenance = list(x='effort', y='uptime', z='technician experience')
)

inputPanel(
  selectInput("scenario", label="select scenario", choices=names(SCENARIOS), selected=1),
  
  selectInput("mode", label="select mode", choices=c('see', 'do'), selected=1),
  
  selectInput("model", label = "Select predictive model:",
              choices = MODEL_NAMES, selected = 2),
  
  uiOutput('x_slider_placeholder'),
  
  uiOutput('z_slider_placeholder'),
  
  textOutput('outcome')

)

output$x_slider_placeholder <- renderUI({
  sliderInput("x", label=paste(SCENARIOS[[input$scenario]]$x,':'),
              min=X_LIM[1], max=X_LIM[2], value= -0.6, step=0.1)
})

output$z_slider_placeholder <- renderUI({
  sliderInput("z", label=paste(SCENARIOS[[input$scenario]]$z,':'),
              min=Z_LIM[1], max=Z_LIM[2], value=5, step=5)
})

output$outcome <- renderText({
  sprintf('outcome: %s', SCENARIOS[[input$scenario]]$y)
})

renderPlot({
  selected_model <- get(input$model)
  input_case <- data.frame(x=input$x, z=input$z, model_name=input$model,
                           stringsAsFactors=FALSE)
  input_case$y <- predicted_outcome <- standard_predict(selected_model, input_case)
  LOGGED_DATA <<- bind_rows(LOGGED_DATA, input_case)
  
  LOGGED_DATA %>% 
    mutate(model_type=gsub('_.*', '', model_name), model_formula=gsub('.*_', '', model_name)) %>% 
    arrange(x) %>% 
    ggplot(aes(x=x, y=y, col=model_type, 
               shape=model_formula, 
               linetype=interaction(model_type, model_formula, z))) + 
    geom_line(size=2) + geom_point(size=4) +
    coord_cartesian(xlim=X_LIM, ylim=Y_LIM) +
    labs(x=SCENARIOS[[input$scenario]]$x, 
         y=SCENARIOS[[input$scenario]]$y,
         col='model type') +
    ggtitle(paste(input$scenario, 'scenario'))
})

```

This app plots the predicted outcome (`y`-value) for given inputs (`x` and`z` values). There are three types of models (lm, randomForest, and nnet) and two formulas (formula `A` is `y ~ x` and formula B is `y ~ x + z`).
